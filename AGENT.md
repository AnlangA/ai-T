# AI Translate Tool - 项目需求文档

## 项目概述

构建一个基于egui的AI文本翻译工具，使用zai-rs提供的GLM-4.7 API进行多语言文本翻译，并集成文本转语音（TTS）功能。

**相关文档：**
- egui: https://github.com/emilk/egui
- zai-rs: https://github.com/AnlangA/zai-rs
- text2audio: https://github.com/AnlangA/text2audio

---

## 1. 总体目标

- 使用 `egui` 构建现代化用户界面
- 使用 `zai-rs` 接口集成 GLM-4.7 模型（coding-plan 模式）
- 支持多种语言的文本翻译
- 实现流式输出和实时显示
- 集成文本转语音（TTS）功能，支持独立的原文和翻译文本音频播放

---

## 2. 架构需求

### 2.1 技术栈
- **UI框架**: egui
- **异步运行时**: tokio
- **AI模型**: zai-rs GLM-4.7 (coding-plan 模式)
- **输出模式**: 流式输出 (streaming)
- **TTS服务**: text2audio (智谱AI GLM-TTS)

### 2.2 架构设计
- **UI与数据处理分离**: 使用tokio进行UI和数据处理之间的通信，确保UI显示流畅性
- **流式数据处理**:
  - 从AI接收流式输出
  - 实时显示到UI
  - 同时保存到日志文件
- **高度结构化和现代化的软件架构**
- **每个子目录需包含 AGENT.md**: 说明该目录下代码的功能，作为开发计划文档
- **TTS与翻译独立**: TTS功能和翻译功能完全独立运行，互不影响

---

## 3. UI需求

### 3.1 布局结构
- **右侧栏**:
  - 顶部: API Key 输入框（使用egui内置保存功能持久化）
  - 中上部: 目标语言选择（支持多语言选择，翻译过程中不可修改）
  - 中部: 源文本输入框
  - 下部: 原文 TTS 转换按钮（独立于翻译，可随时触发）
- **中间区域**: 结构化显示输入文本和翻译结果
  - 源文本行：包含 TTS 播放按钮
  - 翻译文本行：包含 TTS 播放按钮（仅在翻译完成后可用）

### 3.2 功能特性
- **语言支持**: 输入语言由AI自动识别
- **实时翻译**: 流式显示翻译结果
- **现代UI设计**: 支持黑白主题切换
- **字体调整**: 支持字体大小调整
- **TTS功能**:
  - 原文 TTS：输入文本后即可通过按钮触发转换和播放
  - 翻译文本 TTS：仅在翻译完成后可用
  - 音频播放：点击播放按钮播放音频，再次点击停止播放
  - 音色配置：支持7种音色选择
  - 语速调节：支持0.5x-2.0x速度调节
  - 音量调节：支持0.0-10.0音量调节
  - 音频缓存：100条音频缓存，超出删除最早的

### 3.3 TTS优化特性（最新更新）
1. **独立运行**: 文本转语音功能与翻译完全独立，互不影响
2. **原文即时转换**: 原文本输入后即可通过按键触发转语音，无需等待翻译
3. **翻译文本延迟可用**: 翻译后的文本必须等翻译结束后才可以用按键转语音
4. **独立中断**: 原文、翻译文的文本转语音互相独立，播放新音频会自动停止当前播放
5. **手动控制**: 移除了自动启动 TTS 的逻辑，完全由用户通过按钮手动控制

---

## 4. 测试要求

- 代码格式化: `cargo fmt`
- 代码检查: `cargo clippy`
- 单元测试覆盖
- 基础 CI/CD 配置

---

## 5. 日志需求

- 所有对话和翻译结果以文本格式保存到日志文件
- 日志应包含时间戳和完整的翻译上下文

---

## 6. TTS服务详细需求

### 6.1 TTS配置
- **音色选择**: 7种预置音色（童童、吹吹、晓辰、Jam、Kazi、豆鸡、Luodo）
- **语速控制**: 0.5x（慢）至 2.0x（快）
- **音量控制**: 0.0（静音）至 10.0（最大）
- **并行处理**: 支持长文本分段并行转换（最多5个并发）

### 6.2 TTS流程
1. 用户点击原文或翻译文本的 TTS 按钮
2. 检查缓存中是否已有音频
   - 如果有，直接播放缓存音频
   - 如果没有，启动转换任务
3. 显示转换状态（"Converting..."）
4. 后台线程调用 text2audio 进行转换
5. 转换完成后，更新UI并自动播放

### 6.3 音频缓存
- **缓存容量**: 最多100条音频
- **自动清理**: 超出容量时删除最早的音频
- **文件管理**: 自动管理音频文件的存储和清理

---

## 7. 消息传递机制

### 7.1 UiMessage 类型
- `UpdateTranslation`: 翻译文本更新
- `Error`: 错误信息
- `TranslationComplete`: 翻译完成
- `TranslationCancelled`: 翻译取消
- `RequestSourceTts`: 请求原文 TTS
- `RequestTranslationTts`: 请求翻译文本 TTS
- `StopPlayback`: 停止播放
- `SourceTtsStarted`: 原文 TTS 开始
- `TranslationTtsStarted`: 翻译文本 TTS 开始
- `SourceTtsCompleted`: 原文 TTS 完成
- `TranslationTtsCompleted`: 翻译文本 TTS 完成
- `TtsFailed`: TTS 失败
- `PlaybackStateChanged`: 播放状态改变

### 7.2 消息处理
- 使用 `tokio::sync::mpsc::unbounded_channel` 进行异步通信
- UI线程定期通过 `try_recv` 检查新消息
- 为避免借用冲突，消息先收集到 Vector 再批量处理

---

## 8. 最近的修复和改进

### 8.1 音频缓存机制
- **修复**: 使用文本的哈希值作为缓存键，确保相同文本复用相同音频
- **实现**: `AudioCache::generate_key()` 使用 `DefaultHasher` 生成哈希
- **效果**: 避免了重复转换相同文本，提高了性能

### 8.2 独立的 TTS 状态管理
- **问题**: 原文和翻译文本的 TTS 共享同一状态标志，导致互相影响
- **修复**: 添加了两个独立的取消标志：
  - `source_tts_cancel_requested`: 原文 TTS 取消标志
  - `translation_tts_cancel_requested`: 翻译文本 TTS 取消标志
- **效果**: 原文和翻译文本的 TTS 转换完全独立，互不干扰

### 8.3 新翻译时中断音频活动
- **问题**: 开始新翻译时，之前的音频转换和播放仍在继续
- **修复**: 在 `start_translation()` 开始时：
  1. 停止当前音频播放 (`stop_audio()`)
  2. 取消原文 TTS 转换 (`cancel_source_tts()`)
  3. 取消翻译文本 TTS 转换 (`cancel_translation_tts()`)
- **效果**: 开始新翻译时，所有音频活动被干净地中断

### 8.4 翻译取消按键修复
- **问题**: 翻译取消按键点击后无效
- **修复**: 
  - 在 `start_translation()` 开头重置 `cancel_requested` 标志
  - 在异步翻译任务中正确检查取消标志
  - 在 `cancel_translation()` 方法中正确设置取消标志
- **效果**: 翻译取消功能正常工作

### 8.5 TTS 取消按钮
- **新增**: 在原文和翻译文本区域添加了取消按钮（"✕"）
- **显示**: 只在 TTS 转换过程中显示取消按钮
- **功能**: 点击可立即中断正在进行的 TTS 转换
- **效果**: 用户可以随时取消长时间运行的 TTS 转换

### 8.6 音频路径清理
- **问题**: 新翻译时，之前的音频路径仍然显示
- **修复**: 在 `DisplayPanel::clear_translation()` 中清空音频路径
- **效果**: 开始新翻译时，UI 状态被正确重置

### 8.7 消息处理优化
- **问题**: 直接在 `while let Ok(msg) = rx.try_recv()` 循环中修改 `self` 导致借用冲突
- **修复**: 先将所有消息收集到 `Vec<UiMessage>`，再批量处理
- **效果**: 避免了借用冲突，同时保持消息处理的实时性

---

## 9. 技术要点

### 9.1 音频缓存键生成
```rust
fn generate_key(text: &str) -> String {
    let mut hasher = DefaultHasher::new();
    text.hash(&mut hasher);
    format!("{:x}", hasher.finish())
}
```
- 使用 Rust 标准库的 `DefaultHasher`
- 将哈希值转换为十六进制字符串作为缓存键
- 确保相同文本映射到相同音频文件

### 9.2 TTS 转换流程
1. 用户点击 TTS 按钮
2. 检查音频缓存（通过哈希键查找）
3. 如果缓存命中，直接播放；否则启动转换
4. 在新线程中创建独立 Tokio runtime
5. 调用 `text2audio` 进行转换
6. 完成后存储到缓存并发送消息到 UI

### 9.3 独立取消机制
- 每个异步任务（翻译、原文 TTS、翻译文本 TTS）都有独立的 `Arc<Mutex<bool>>` 取消标志
- 任务在执行前检查取消标志
- 回调函数中也检查取消标志
- 确保及时响应取消请求
